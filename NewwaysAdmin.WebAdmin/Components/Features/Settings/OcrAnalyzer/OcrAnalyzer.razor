@* NewwaysAdmin.WebAdmin/Components/Features/Settings/OcrAnalyzer/OcrAnalyzer.razor *@
@* Simple OCR Analyzer Component *@
@using Microsoft.AspNetCore.Components.Forms
@using NewwaysAdmin.WebAdmin.Services.Testing
@inject IOcrTestingService OcrTestingService

<div style="padding: 20px; background: lightblue; border: 5px solid red; margin: 20px;">
    <h1>OCR ANALYZER - SIMPLE VERSION</h1>

    <div style="background: yellow; padding: 10px; margin: 10px 0;">
        <h3>Test Counter: @testCounter</h3>
        <button @onclick="IncrementCounter" style="padding: 10px; font-size: 16px;">
            Click Me (+1)
        </button>
    </div>

    <div style="background: orange; padding: 10px; margin: 10px 0;">
        <h3>Upload File:</h3>
        <InputFile OnChange="HandleFile" />
        <p><strong>Status:</strong> @status</p>
    </div>

    <div style="background: green; color: white; padding: 10px; margin: 10px 0;">
        <h3>OCR Result:</h3>
        <p><strong>Text Length:</strong> @textResult.Length characters</p>
        <div style="background: white; color: black; padding: 10px; max-height: 300px; overflow-y: auto; font-family: monospace;">
            @if (!string.IsNullOrEmpty(textResult))
            {
                @if (!string.IsNullOrEmpty(regexPattern))
                {
                    @((MarkupString)GetHighlightedText())
                }
                else
                {
                    <pre>@textResult</pre>
                }
            }
            else
            {
                <em>No text extracted yet</em>
            }
        </div>
    </div>

    <!-- NEW: Regex Pattern Testing Section -->
    @if (!string.IsNullOrEmpty(textResult))
    {
        <div style="background: cyan; color: black; padding: 10px; margin: 10px 0;">
            <h3>🔍 Regex Pattern Testing</h3>

            <div style="margin: 10px 0;">
                <label><strong>Enter Regex Pattern:</strong></label>
                <input @bind="regexPattern"
                       @bind:event="oninput"
                       @onkeypress="HandleKeyPress"
                       placeholder="e.g., \d{1,3}(,\d{3})*\.\d{2}\s*บาท"
                       style="width: 100%; padding: 8px; font-family: monospace; font-size: 14px;" />
                <small style="display: block; margin-top: 5px; color: #666;">
                    Try: <code>\d+,\d+\.\d+\s*บาท</code> (amounts) | <code>\d{2}\s+[ก-๙]+\.\s+\d{2}</code> (dates) | <code>xxx-x-x\d+-x</code> (accounts)
                </small>
            </div>

            <div style="margin: 10px 0;">
                <button @onclick="AddPattern"
                        disabled="@string.IsNullOrWhiteSpace(regexPattern)"
                        style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px;">
                    ➕ Add Pattern
                </button>
                <button @onclick="ClearPatterns"
                        disabled="@(!activePatterns.Any())"
                        style="padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 4px; margin-left: 10px;">
                    🗑️ Clear All
                </button>
            </div>

            @if (activePatterns.Any())
            {
                <div style="margin: 10px 0;">
                    <strong>Active Patterns:</strong>
                    <div style="margin: 5px 0;">
                        @foreach (var pattern in activePatterns.Select((p, i) => new { Pattern = p, Index = i }))
                        {
                            <span style="display: inline-block; margin: 2px; padding: 4px 8px; background: @GetPatternColor(pattern.Index); border-radius: 3px; font-family: monospace; font-size: 12px;">
                                @pattern.Pattern
                                <button @onclick="() => RemovePattern(pattern.Index)"
                                        style="margin-left: 5px; background: none; border: none; color: #333; cursor: pointer;">
                                    ✖
                                </button>
                            </span>
                        }
                    </div>
                </div>
            }

            @if (!string.IsNullOrEmpty(regexPattern))
            {
                <div style="margin: 10px 0; padding: 10px; background: #f8f9fa; border-radius: 4px;">
                    <strong>Pattern Results:</strong>
                    @if (regexError != null)
                    {
                        <div style="color: red; font-weight: bold;">❌ Error: @regexError</div>
                    }
                    else
                    {
                        <div style="color: green; font-weight: bold;">✅ @matchCount matches found</div>
                        @if (matches.Any())
                        {
                            <div style="margin-top: 10px; max-height: 150px; overflow-y: auto;">
                                @foreach (var match in matches.Take(10))
                                {
                                    <div style="margin: 5px 0; padding: 5px; background: white; border-left: 3px solid #007bff;">
                                        <strong>Match:</strong> <code>@match.Value</code>
                                        <small>(pos: @match.Index)</small>
                                        @if (match.Groups.Count > 1)
                                        {
                                            <div style="margin-left: 20px; font-size: 12px;">
                                                @for (int i = 1; i < match.Groups.Count; i++)
                                                {
                                                    <span style="margin-right: 10px;">Group @i: <code>@match.Groups[i].Value</code></span>
                                                }
                                            </div>
                                        }
                                    </div>
                                }
                                @if (matches.Count > 10)
                                {
                                    <div style="text-align: center; font-style: italic; color: #666;">
                                        ... and @(matches.Count - 10) more matches
                                    </div>
                                }
                            </div>
                        }
                    }
                </div>
            }
        </div>
    }

    <div style="background: purple; color: white; padding: 10px; margin: 10px 0;">
        <h3>Debug Info:</h3>
        <p><strong>Current Time:</strong> @DateTime.Now.ToString("HH:mm:ss")</p>
        <p><strong>Counter:</strong> @testCounter</p>
        <p><strong>Status:</strong> @status</p>
        <p><strong>Text Length:</strong> @textResult.Length</p>
        <p><strong>Service Available:</strong> @(OcrTestingService != null ? "Yes" : "No")</p>
    </div>
</div>

@code {
    private int testCounter = 0;
    private string status = "Ready - Click counter to test UI";
    private string textResult = "";

    // Regex testing variables
    private string regexPattern = "";
    private List<string> activePatterns = new();
    private List<System.Text.RegularExpressions.Match> matches = new();
    private int matchCount = 0;
    private string? regexError = null;

    private void IncrementCounter()
    {
        testCounter++;
        status = $"Counter clicked at {DateTime.Now:HH:mm:ss} - UI is working!";
        StateHasChanged();
    }

    private async Task HandleKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !string.IsNullOrWhiteSpace(regexPattern))
        {
            AddPattern();
        }
    }

    private void AddPattern()
    {
        if (!string.IsNullOrWhiteSpace(regexPattern) && !activePatterns.Contains(regexPattern))
        {
            activePatterns.Add(regexPattern);
            regexPattern = "";
            StateHasChanged();
        }
    }

    private void RemovePattern(int index)
    {
        if (index >= 0 && index < activePatterns.Count)
        {
            activePatterns.RemoveAt(index);
            StateHasChanged();
        }
    }

    private void ClearPatterns()
    {
        activePatterns.Clear();
        regexPattern = "";
        StateHasChanged();
    }

    private string GetPatternColor(int index)
    {
        var colors = new[] { "#ffeb3b", "#4caf50", "#2196f3", "#ff9800", "#9c27b0" };
        return colors[index % colors.Length];
    }

    private string GetHighlightedText()
    {
        if (string.IsNullOrEmpty(textResult)) return textResult;

        var highlightedText = textResult;
        var highlightColors = new[] { "#ffeb3b", "#4caf50", "#2196f3", "#ff9800", "#9c27b0" };

        // Test current pattern first
        if (!string.IsNullOrEmpty(regexPattern))
        {
            TestCurrentPattern();
        }

        // Apply highlights for all active patterns + current pattern
        var allPatterns = new List<string>(activePatterns);
        if (!string.IsNullOrEmpty(regexPattern))
        {
            allPatterns.Add(regexPattern);
        }

        // Apply highlights in reverse order to maintain indices
        for (int patternIndex = allPatterns.Count - 1; patternIndex >= 0; patternIndex--)
        {
            try
            {
                var regex = new System.Text.RegularExpressions.Regex(allPatterns[patternIndex], System.Text.RegularExpressions.RegexOptions.IgnoreCase);
                var patternMatches = regex.Matches(highlightedText).Cast<System.Text.RegularExpressions.Match>().OrderByDescending(m => m.Index);
                var color = highlightColors[patternIndex % highlightColors.Length];

                foreach (var match in patternMatches)
                {
                    var before = highlightedText.Substring(0, match.Index);
                    var matchText = highlightedText.Substring(match.Index, match.Length);
                    var after = highlightedText.Substring(match.Index + match.Length);

                    var highlighted = $"<span style=\"background-color: {color}; padding: 1px 2px; border-radius: 2px; font-weight: bold;\">{System.Net.WebUtility.HtmlEncode(matchText)}</span>";
                    highlightedText = before + highlighted + after;
                }
            }
            catch
            {
                // Ignore invalid regex patterns for highlighting
            }
        }

        return highlightedText.Replace("\n", "<br/>");
    }

    private void TestCurrentPattern()
    {
        if (string.IsNullOrWhiteSpace(regexPattern) || string.IsNullOrEmpty(textResult))
        {
            matches.Clear();
            matchCount = 0;
            regexError = null;
            return;
        }

        try
        {
            var regex = new System.Text.RegularExpressions.Regex(regexPattern, System.Text.RegularExpressions.RegexOptions.IgnoreCase);
            var regexMatches = regex.Matches(textResult);
            matches = regexMatches.Cast<System.Text.RegularExpressions.Match>().ToList();
            matchCount = matches.Count;
            regexError = null;
        }
        catch (Exception ex)
        {
            matches.Clear();
            matchCount = 0;
            regexError = ex.Message;
        }
    }

    private async Task HandleFile(InputFileChangeEventArgs e)
    {
        if (e.File == null) return;

        status = "Processing image with OCR...";
        textResult = "";
        StateHasChanged();

        try
        {
            // Create temp file
            var tempPath = Path.GetTempFileName();
            var finalPath = Path.ChangeExtension(tempPath, Path.GetExtension(e.File.Name));

            status = $"Created temp file: {Path.GetFileName(finalPath)}";
            StateHasChanged();

            // Save uploaded file
            using var stream = e.File.OpenReadStream(maxAllowedSize: 50 * 1024 * 1024);
            using var fileStream = File.Create(finalPath);
            await stream.CopyToAsync(fileStream);
            fileStream.Close();

            status = "File saved, calling OCR service...";
            StateHasChanged();

            // Process with OCR service
            var result = await OcrTestingService.ProcessImageWithExistingPipelineAsync(finalPath, null);

            if (result?.Success == true && !string.IsNullOrEmpty(result.ExtractedText))
            {
                textResult = result.ExtractedText;
                status = $"SUCCESS! Extracted {textResult.Length} characters";
            }
            else
            {
                textResult = "";
                status = $"FAILED: {result?.ErrorMessage ?? "Unknown error"}";
            }

            // Cleanup
            try { File.Delete(finalPath); } catch { }
        }
        catch (Exception ex)
        {
            textResult = "";
            status = $"EXCEPTION: {ex.Message}";
        }

        StateHasChanged();
    }
}