@* NewwaysAdmin.WebAdmin/Components/Features/Settings/OcrAnalyzer/Core/Views/PatternView.razor *@
@using NewwaysAdmin.SharedModels.Services.Ocr
@using WordBoundingBox = NewwaysAdmin.SharedModels.Models.Ocr.Core.WordBoundingBox;
@using NewwaysAdmin.WebAdmin.Components.Features.Settings.OcrAnalyzer.Core.Components
@using NewwaysAdmin.SharedModels.Models.Ocr
@implements IDisposable
@inject IJSRuntime JSRuntime
@inject PatternManagementService PatternService
@inject SpatialPatternMatcher SpatialPatternMatcher

<div class="patterns-section">

    <!-- Pattern Save Component -->
    <ThreeLevelPatternSaveComponent CurrentPattern="@GetCurrentSearchPattern()"
                                    OnPatternSaved="@OnPatternSaved" />

    <!-- Streamlined Pattern Browser Component -->
    <PatternBrowserComponent OnPatternLoaded="@HandlePatternLoaded"
                             OnPatternSaveRequested="@HandlePatternSaveRequest" />

    <div class="row">
        <!-- Left: Pattern Configuration -->
        <div class="col-md-4">
            <div class="pattern-config-panel">
                <h5><i class="bi bi-gear"></i> Pattern Configuration</h5>

                <!-- Pattern Type -->
                <div class="config-group">
                    <label class="config-label">Pattern Type</label>
                    <select @bind="State.SelectedPatternType" class="form-select form-select-sm">
                        <option value="VerticalColumn">Vertical Column</option>
                        <option value="Horizontal">Horizontal</option>
                        <option value="PositionBasedColumn">Position Based Column</option>
                        <option value="PositionBasedHorizontal">Position Based Horizontal</option>
                        <option value="Sequential" disabled>Sequential (Coming Soon)</option>
                    </select>
                </div>

                <!-- Search Term -->
                <div class="config-group">
                    <label class="config-label">Search Term</label>
                    <input @bind="State.PatternSearchTerm" class="form-control form-control-sm"
                           placeholder="e.g., To, ไปยัง, Total" />
                </div>

                <!-- Tolerances -->
                <div class="config-group">
                    <label class="config-label">Y Tolerance (pixels)</label>
                    <input @bind="State.PatternYTolerance" type="number" class="form-control form-control-sm"
                           min="5" max="100" />
                    <small class="form-text">Max gap between lines before stopping</small>
                </div>

                <div class="config-group">
                    <label class="config-label">X Tolerance (pixels)</label>
                    <input @bind="State.PatternXTolerance" type="number" class="form-control form-control-sm"
                           min="1" max="50" />
                    <small class="form-text">Tolerance for same-line alignment</small>
                </div>

                <!-- Stop Words -->
                <div class="config-group">
                    <label class="config-label">Stop Words (optional)</label>
                    <input @bind="State.PatternStopWords" class="form-control form-control-sm"
                           placeholder="e.g., Total, End (comma separated)" />
                    <small class="form-text">Hard stop when these words are found</small>
                </div>

                <!-- NEW: Regex Pattern Editor -->
                <div class="config-group">
                    <label class="config-label">Regex Patterns</label>

                    <!-- Add new regex pattern -->
                    <div class="input-group mb-2">
                        <input @bind="newRegexPattern"
                               class="form-control form-control-sm"
                               placeholder="Enter regex pattern (e.g., \d+, [A-Z]+)"
                               style="font-family: monospace;"
                               @onkeypress="@(async (e) => { if (e.Key == "Enter") await AddRegexPattern(); })" />
                        <button @onclick="AddRegexPattern"
                                class="btn btn-outline-primary btn-sm"
                                disabled="@(string.IsNullOrWhiteSpace(newRegexPattern))"
                                title="Add regex pattern">
                            <i class="bi bi-plus"></i>
                        </button>
                    </div>

                    <!-- List of current regex patterns -->
                    @if (currentRegexPatterns.Any())
                    {
                        <div class="border rounded p-2 mb-2" style="background: #f8f9fa; max-height: 120px; overflow-y: auto;">
                            @foreach (var (pattern, index) in currentRegexPatterns.Select((p, i) => (p, i)))
                            {
                                <div class="d-flex justify-content-between align-items-center mb-1 p-1"
                                     style="background: white; border: 1px solid #ddd; border-radius: 3px;">
                                    <code style="font-size: 0.75rem; flex-grow: 1; margin-right: 0.5rem;">@pattern</code>
                                    <button @onclick="() => RemoveRegexPattern(index)"
                                            class="btn btn-sm btn-outline-danger py-0 px-1"
                                            title="Remove this pattern">
                                        <i class="bi bi-x"></i>
                                    </button>
                                </div>
                            }
                        </div>
                        <small class="form-text">@currentRegexPatterns.Count pattern(s) - will be saved with the pattern</small>
                    }
                    else
                    {
                        <small class="form-text">No regex patterns added yet (optional)</small>
                    }
                </div>

                <!-- Test Button -->
                <button @onclick="TestCurrentPattern" class="btn btn-primary btn-sm w-100"
                        disabled="@(string.IsNullOrEmpty(State.PatternSearchTerm))">
                    <i class="bi bi-play"></i> Test Pattern
                </button>

                <!-- Clear Button -->
                @if (State.CurrentPatternResult != null)
                {
                    <button @onclick="State.ClearPatternResults" class="btn btn-outline-secondary btn-sm w-100 mt-2">
                        <i class="bi bi-eraser"></i> Clear Results
                    </button>
                }
            </div>

            <!-- Results Panel -->
            <PatternResultsPanel PatternResult="@State.CurrentPatternResult"
                                 SearchTerm="@State.PatternSearchTerm"
                                 OnRegexPatternChanged="@OnRegexPatternChanged" />
        </div>

        <!-- Right: Visual Results -->
        <div class="col-md-8">
            <div class="pattern-visualization">
                <div class="viz-header">
                    <h6><i class="bi bi-eye"></i> Visual Results</h6>
                    <div class="viz-controls">
                        <div class="form-check form-check-inline">
                            <input @bind="State.ShowAllWordsInPattern" class="form-check-input" type="checkbox" id="showAllPattern">
                            <label class="form-check-label" for="showAllPattern">Show All Words</label>
                        </div>
                        <div class="form-check form-check-inline">
                            <input @bind="State.ShowPatternOverlay" class="form-check-input" type="checkbox" id="showPattern">
                            <label class="form-check-label" for="showPattern">Show Pattern Results</label>
                        </div>
                    </div>
                </div>

                <div class="pattern-heatmap" style="@State.GetVisualizationStyle()">
                    <!-- All Words Heat Map (when enabled) -->
                    @if (State.ShowAllWordsInPattern && State.SpatialResult?.Document?.Words != null)
                    {
                        @foreach (var word in State.GetFilteredWords())
                        {
                            <div class="heat-word-dot" style="@GetHeatWordStyle(word)"
                                 title="@GetWordTooltip(word)"
                                 @onclick="@((MouseEventArgs e) => CopyWordOrCoordinates(word))"></div>
                        }
                    }

                    <!-- Pattern Results Overlay (when enabled) -->
                    @if (State.ShowPatternOverlay && State.CurrentPatternResult?.Success == true)
                    {
                        <!-- Anchor Word (Red) -->
                        @if (State.CurrentPatternResult.AnchorWord != null)
                        {
                            <div class="pattern-anchor" style="@GetPatternAnchorStyle(State.CurrentPatternResult.AnchorWord)"
                                 title="@GetWordTooltip(State.CurrentPatternResult.AnchorWord, "Anchor: ")"
                                 @onclick="@((MouseEventArgs e) => CopyWordOrCoordinates(State.CurrentPatternResult.AnchorWord))"></div>
                        }

                        <!-- Grouped Words (Green) -->
                        @foreach (var word in State.CurrentPatternResult.GroupedWords.Where(w => w != State.CurrentPatternResult.AnchorWord))
                        {
                            <div class="pattern-grouped" style="@GetPatternGroupStyle(word)"
                                 title="@GetWordTooltip(word, "Grouped: ")"
                                 @onclick="@((MouseEventArgs e) => CopyWordOrCoordinates(word))"></div>
                        }
                    }
                </div>

                <!-- Legend -->
                @if (State.CurrentPatternResult?.Success == true)
                {
                    <div class="pattern-legend mt-2">
                        <div class="legend-item">
                            <div class="legend-color anchor-color"></div>
                            <span>Anchor Word (@State.CurrentPatternResult.AnchorWord?.Text)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color grouped-color"></div>
                            <span>Grouped Words (@(State.CurrentPatternResult.GroupedWords.Count - 1))</span>
                        </div>
                        @if (State.ShowAllWordsInPattern)
                        {
                            <div class="legend-item">
                                <div class="legend-color heat-color"></div>
                                <span>All Words</span>
                            </div>
                        }
                    </div>
                }
            </div>
        </div>
    </div>
</div>

@code {
    [Parameter, EditorRequired] public SpatialOcrAnalyzerState State { get; set; } = default!;

    private string currentRegexPattern = "";
    private List<string> currentRegexPatterns = new(); // NEW: List to manage multiple regex patterns
    private string newRegexPattern = ""; // NEW: For adding new patterns
    private bool IsPositionBasedPattern =>
    State.SelectedPatternType?.Contains("positionbased", StringComparison.OrdinalIgnoreCase) == true;

    // NEW: Smart copy method that copies coordinates or word based on pattern type
private async Task CopyWordOrCoordinates(WordBoundingBox word)
    {
        if (word == null) return;

        string textToCopy;
        if (IsPositionBasedPattern)
        {
            // For position-based patterns, copy coordinates
            textToCopy = $"{word.RawX1},{word.RawY1}";
        }
        else
        {
            // For keyword-based patterns, copy word text
            textToCopy = word.Text;
        }

        try
        {
            await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", textToCopy);
        }
        catch (Exception)
        {
            // Fallback for older browsers - could show a message
        }
    }

    private void OnRegexPatternChanged(string regexPattern)
    {
        currentRegexPattern = regexPattern;
        Console.WriteLine($"Regex pattern changed to: '{regexPattern}'");
    }

    protected override void OnInitialized()
    {
        State.StateChanged += StateHasChanged;
    }

    public void Dispose()
    {
        State.StateChanged -= StateHasChanged;
    }

    // UPDATED: Enhanced tooltip method that shows what will be copied
    private string GetWordTooltip(WordBoundingBox word, string prefix = "")
    {
        var wordInfo = string.IsNullOrEmpty(prefix) ? $"Word: \"{word.Text}\"" : $"{prefix}\"{word.Text}\"";
        var coordinates = $"Coordinates: {word.RawX1},{word.RawY1}";

        string clickToCopy;
        if (IsPositionBasedPattern)
        {
            clickToCopy = $"Click to copy: {word.RawX1},{word.RawY1}";
        }
        else
        {
            clickToCopy = $"Click to copy: {word.Text}";
        }

        return $"{wordInfo}\n{coordinates}\n{clickToCopy}";
    }

    // NEW: Handle pattern save request from PatternBrowserComponent
    private async Task HandlePatternSaveRequest(NewwaysAdmin.WebAdmin.Components.Features.Settings.OcrAnalyzer.Core.Components.PatternBrowserComponent.SavePatternRequest saveRequest)
    {
        Console.WriteLine($"=== SAVE REQUEST RECEIVED ===");
        Console.WriteLine($"Pattern Name: {saveRequest.PatternName}");
        Console.WriteLine($"Document Type: {saveRequest.DocumentType}");
        Console.WriteLine($"Format: {saveRequest.Format}");

        try
        {
            // Check if we have a valid search term
            if (string.IsNullOrEmpty(State.PatternSearchTerm))
            {
                Console.WriteLine("ERROR: No search term in State.PatternSearchTerm");
                return;
            }

            // Check our regex patterns
            Console.WriteLine($"Current regex patterns count: {currentRegexPatterns.Count}");
            foreach (var pattern in currentRegexPatterns)
            {
                Console.WriteLine($"  - '{pattern}'");
            }

            // Create pattern to save with current tester values - INCLUDING all regex patterns
            var patternToSave = new SearchPattern
                {
                    SearchName = saveRequest.PatternName, // Keep original name
                    KeyWord = State.PatternSearchTerm, // Use current search term directly
                    PatternType = State.SelectedPatternType ?? "VerticalColumn",
                    ToleranceX = State.PatternXTolerance,
                    ToleranceY = State.PatternYTolerance,
                    StopWords = State.PatternStopWords ?? "",
                    RegexPatterns = currentRegexPatterns.ToList() // Use the full list
                };

            // Debug: Log what we're about to save
            Console.WriteLine($"=== PATTERN TO SAVE ===");
            Console.WriteLine($"SearchName: {patternToSave.SearchName}");
            Console.WriteLine($"KeyWord: {patternToSave.KeyWord}");
            Console.WriteLine($"PatternType: {patternToSave.PatternType}");
            Console.WriteLine($"ToleranceX: {patternToSave.ToleranceX}");
            Console.WriteLine($"ToleranceY: {patternToSave.ToleranceY}");
            Console.WriteLine($"StopWords: {patternToSave.StopWords}");
            Console.WriteLine($"RegexPatterns Count: {patternToSave.RegexPatterns?.Count ?? 0}");
            if (patternToSave.RegexPatterns != null)
            {
                for (int i = 0; i < patternToSave.RegexPatterns.Count; i++)
                {
                    Console.WriteLine($"  Regex {i}: '{patternToSave.RegexPatterns[i]}'");
                }
            }

            // Check if PatternService is available
            if (PatternService == null)
            {
                Console.WriteLine("ERROR: PatternService is null!");
                return;
            }

            Console.WriteLine("Calling PatternService.SaveSearchPatternAsync...");

            // Save the pattern
            var success = await PatternService.SaveSearchPatternAsync(
                saveRequest.DocumentType,
                saveRequest.Format,
                saveRequest.PatternName,
                patternToSave);

            Console.WriteLine($"Save result: {success}");

            if (success)
            {
                Console.WriteLine("Save successful! Loading back to verify...");

                // Debug: Load it back and see what we get
                var loadedBack = await PatternService.LoadSearchPatternAsync(
                    saveRequest.DocumentType,
                    saveRequest.Format,
                    saveRequest.PatternName);

                Console.WriteLine($"=== LOADED BACK ===");
                if (loadedBack != null)
                {
                    Console.WriteLine($"Loaded KeyWord: {loadedBack.KeyWord}");
                    Console.WriteLine($"Loaded Regex Patterns Count: {loadedBack.RegexPatterns?.Count ?? 0}");
                    if (loadedBack.RegexPatterns != null)
                    {
                        for (int i = 0; i < loadedBack.RegexPatterns.Count; i++)
                        {
                            Console.WriteLine($"  Loaded Regex {i}: '{loadedBack.RegexPatterns[i]}'");
                        }
                    }
                }
                else
                {
                    Console.WriteLine("ERROR: Loaded pattern is null!");
                }

                // Success - pattern was overwritten
                StateHasChanged();
            }
            else
            {
                Console.WriteLine("ERROR: Save returned false");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"EXCEPTION saving pattern: {ex.Message}");
            Console.WriteLine($"Exception type: {ex.GetType().Name}");
            Console.WriteLine($"Stack trace: {ex.StackTrace}");

            if (ex.InnerException != null)
            {
                Console.WriteLine($"Inner exception: {ex.InnerException.Message}");
            }
        }
    }
    // NEW: Handle pattern loading from PatternBrowserComponent
    private void HandlePatternLoaded(NewwaysAdmin.WebAdmin.Components.Features.Settings.OcrAnalyzer.Core.Components.PatternBrowserComponent.LoadedPatternData loadedPattern)
    {
        // Populate the pattern tester with the loaded pattern values
        State.SelectedPatternType = loadedPattern.PatternType;
        State.PatternSearchTerm = loadedPattern.KeyWord;
        State.PatternXTolerance = loadedPattern.ToleranceX;
        State.PatternYTolerance = loadedPattern.ToleranceY;
        State.PatternStopWords = loadedPattern.StopWords;

        // Load the regex patterns into our list
        currentRegexPatterns = loadedPattern.RegexPatterns?.ToList() ?? new List<string>();

        // Update the legacy single pattern for compatibility (use first pattern or empty)
        currentRegexPattern = currentRegexPatterns.FirstOrDefault() ?? "";

        // Clear any existing pattern results since we changed the configuration
        State.CurrentPatternResult = null;

        // Trigger UI update
        StateHasChanged();
    }

    private void TestCurrentPattern()
    {
        if (State.SpatialResult?.Document == null || string.IsNullOrEmpty(State.PatternSearchTerm))
        {
            State.CurrentPatternResult = new PatternTestResult { Success = false };
            return;
        }

        try
        {
            if (State.SelectedPatternType == "VerticalColumn")
            {
                State.CurrentPatternResult = TestVerticalColumnPattern();
            }
            else if (State.SelectedPatternType == "Horizontal")
            {
                State.CurrentPatternResult = TestHorizontalPattern();
            }
            else if (State.SelectedPatternType == "PositionBasedColumn")
            {
                State.CurrentPatternResult = TestPositionBasedColumnPattern();
            }
            else if (State.SelectedPatternType == "PositionBasedHorizontal")
            {
                State.CurrentPatternResult = TestPositionBasedHorizontalPattern();
            }
            else
            {
                State.CurrentPatternResult = new PatternTestResult { Success = false };
            }
        }
        catch (Exception ex)
        {
            State.CurrentPatternResult = new PatternTestResult { Success = false };
        }
    }
    private PatternTestResult TestPositionBasedHorizontalPattern()
    {
        try
        {
            var spatialResult = SpatialPatternMatcher.ExtractPattern(
                document: State.SpatialResult.Document,
                searchTerm: State.PatternSearchTerm, // "100,150" - X ignored, Y=150 used
                patternType: "positionbasedhorizontal",
                yTolerance: State.PatternYTolerance,
                xTolerance: State.PatternXTolerance,
                stopWords: State.PatternStopWords ?? "",
                patternName: "TestPattern"
            );

            return ConvertToLocalResult(spatialResult);
        }
        catch (Exception ex)
        {
            return new PatternTestResult { Success = false };
        }
    }
    private PatternTestResult TestPositionBasedColumnPattern()
    {
        try
        {
            // Use the shared SpatialPatternMatcher (same logic as bank slip processing)
            var spatialResult = SpatialPatternMatcher.ExtractPattern(
                document: State.SpatialResult.Document,
                searchTerm: State.PatternSearchTerm, // "189,373"
                patternType: "positionbasedcolumn",
                yTolerance: State.PatternYTolerance,
                xTolerance: State.PatternXTolerance,
                stopWords: State.PatternStopWords ?? "",
                patternName: "TestPattern"
            );

            // Convert SpatialPatternResult to local PatternTestResult format
            return ConvertToLocalResult(spatialResult);
        }
        catch (Exception ex)
        {
            return new PatternTestResult { Success = false };
        }
    }

    private PatternTestResult ConvertToLocalResult(SpatialPatternResult spatialResult)
    {
        var localResult = new PatternTestResult
            {
                Success = spatialResult.Success,
                AnchorWord = spatialResult.AnchorWord,
                GroupedWords = spatialResult.GroupedWords.ToList(),
                CombinedText = spatialResult.CombinedText
            };

        return localResult;
    }

    private PatternTestResult TestHorizontalPattern()
    {
        var result = new PatternTestResult();
        var document = State.SpatialResult!.Document!;

        // Find anchor word
        var anchorWord = document.FindWordsByText(State.PatternSearchTerm, exactMatch: false).FirstOrDefault();
        if (anchorWord == null)
        {
            return result; // Success = false by default
        }

        result.AnchorWord = anchorWord;
        result.GroupedWords.Add(anchorWord);

        // Parse stop words (required for horizontal search)
        var stopWords = GetStopWordsList();
        if (!stopWords.Any())
        {
            return result; // Horizontal search requires stop words
        }

        // Search horizontally right-only from anchor using bounding box gaps
        var currentWord = anchorWord;

        while (true)
        {
            // Find next word to the right within Y tolerance
            // For horizontal search: unlimited X range, just find next word in line
            var nextWord = document.Words
                .Where(w => !result.GroupedWords.Contains(w))
                .Where(w => w.RawX1 > currentWord.RawX2) // Must start after current word ends
                .Where(w => Math.Abs(w.RawCenterY - currentWord.RawCenterY) <= State.PatternYTolerance) // Y tolerance for horizontal alignment
                .OrderBy(w => w.RawX1) // Closest word to the right
                .FirstOrDefault();

            if (nextWord == null)
                break; // No more words found

            // FIXED: Add word to result FIRST
            result.GroupedWords.Add(nextWord);

            // Check if this is a stop word - if so, stop AFTER including it
            if (stopWords.Any(stop => nextWord.Text.Contains(stop, StringComparison.OrdinalIgnoreCase)))
            {
                break; // Stop here, but we've already included the stop word
            }

            // Update current word for next iteration
            currentWord = nextWord;
        }

        result.Success = result.GroupedWords.Count > 1; // Need at least anchor + 1 word
        result.CombinedText = string.Join(" ", result.GroupedWords.Select(w => w.Text));

        return result;
    }

    private List<string> GetStopWordsList()
    {
        return State.PatternStopWords.Split(',', StringSplitOptions.RemoveEmptyEntries)
                                    .Select(w => w.Trim())
                                    .Where(w => !string.IsNullOrEmpty(w))
                                    .ToList();
    }

    private PatternTestResult TestVerticalColumnPattern()
    {
        var result = new PatternTestResult();
        var document = State.SpatialResult!.Document!;

        // Step 1: Find anchor word
        var anchorWord = document.FindWordsByText(State.PatternSearchTerm, exactMatch: false).FirstOrDefault();
        if (anchorWord == null)
        {
            return result; // Success = false
        }

        result.AnchorWord = anchorWord;
        result.GroupedWords.Add(anchorWord);

        // Parse stop words
        var stopWords = GetStopWordsList();

        // Step 2: Establish marching coordinate (left bottom corner of anchor)
        int marchingX = anchorWord.RawX1;
        int marchingY = anchorWord.RawY2;

        while (true)
        {
            // Step 3: March downward on Y with ±5px X tolerance
            var foundWord = document.Words
                .Where(w => !result.GroupedWords.Contains(w))
                .Where(w => w.RawY1 > marchingY && w.RawY1 <= marchingY + State.PatternYTolerance) // Below marching Y within tolerance
                .Where(w => Math.Abs(w.RawX1 - marchingX) <= 5) // ±5px X tolerance from marching coordinate
                .OrderBy(w => w.RawY1) // Closest Y first
                .FirstOrDefault();

            if (foundWord == null)
            {
                // No word found directly below, try to find ANY word in Y range within X tolerance
                var anyWordInRange = document.Words
                    .Where(w => !result.GroupedWords.Contains(w))
                    .Where(w => w.RawY1 > marchingY && w.RawY1 <= marchingY + State.PatternYTolerance)
                    .Where(w => Math.Abs(w.RawX1 - marchingX) <= State.PatternXTolerance) // Within X tolerance of marching coordinate
                    .OrderBy(w => w.RawY1)
                    .FirstOrDefault();

                if (anyWordInRange == null)
                    break; // No more lines found

                foundWord = anyWordInRange;
            }

            // Step 4: March LEFT from found word to establish line left boundary
            var lineWords = new List<WordBoundingBox> { foundWord };
            var currentWord = foundWord;

            // March left using collision detection
            while (true)
            {
                var leftWord = document.Words
                    .Where(w => !result.GroupedWords.Contains(w) && !lineWords.Contains(w))
                    .Where(w => w.RawX2 <= currentWord.RawX1) // To the left of current word
                    .Where(w => currentWord.RawX1 - w.RawX2 <= State.PatternXTolerance) // Within X gap tolerance
                    .Where(w => !(w.RawY2 < currentWord.RawY1 || w.RawY1 > currentWord.RawY2)) // Y ranges would overlap if slid horizontally (collision detection)
                    .OrderByDescending(w => w.RawX2) // Closest to current word
                    .FirstOrDefault();

                if (leftWord == null)
                    break; // No more words to the left

                lineWords.Insert(0, leftWord); // Add to beginning
                currentWord = leftWord;
            }

            // Update marching coordinate to leftmost word's left bottom corner
            var leftmostWord = lineWords.First();
            marchingX = leftmostWord.RawX1;

            // Step 5: March RIGHT from marching coordinate (leftmost word)
            currentWord = leftmostWord;
            while (true)
            {
                var rightWord = document.Words
                    .Where(w => !result.GroupedWords.Contains(w) && !lineWords.Contains(w))
                    .Where(w => w.RawX1 >= currentWord.RawX2) // To the right of current word
                    .Where(w => w.RawX1 - currentWord.RawX2 <= State.PatternXTolerance) // Within X gap tolerance
                    .Where(w => !(w.RawY2 < currentWord.RawY1 || w.RawY1 > currentWord.RawY2)) // Y ranges would overlap if slid horizontally (collision detection)
                    .OrderBy(w => w.RawX1) // Closest to current word
                    .FirstOrDefault();

                if (rightWord == null)
                    break; // No more words to the right

                lineWords.Add(rightWord); // Add to end
                currentWord = rightWord;
            }

            // Check for stop words
            if (stopWords.Any() && lineWords.Any(w => stopWords.Any(stop =>
                w.Text.Contains(stop, StringComparison.OrdinalIgnoreCase))))
            {
                break; // Stop here
            }

            // Safety check: Look for missed symbols within the line boundaries
            var lineYTop = lineWords.Min(w => w.RawY1);
            var lineYBottom = lineWords.Max(w => w.RawY2);
            var lineXLeft = lineWords.Min(w => w.RawX1);
            var lineXRight = lineWords.Max(w => w.RawX2);

            // Look for any small symbols in the same Y area that might have been missed
            var missedSymbols = document.Words
                .Where(w => !result.GroupedWords.Contains(w) && !lineWords.Contains(w))
                .Where(w => w.RawY1 >= lineYTop && w.RawY2 <= lineYBottom) // Within line height
                .Where(w => w.RawX1 >= lineXLeft && w.RawX2 <= lineXRight) // Within line width
                .Where(w => w.Text.Length <= 2) // Only small symbols/characters
                .ToList();

            // Insert missed symbols in the correct X position within lineWords
            foreach (var symbol in missedSymbols)
            {
                // Find correct insertion point based on X position
                var insertIndex = lineWords.Count;
                for (int i = 0; i < lineWords.Count; i++)
                {
                    if (symbol.RawX1 < lineWords[i].RawX1)
                    {
                        insertIndex = i;
                        break;
                    }
                }
                lineWords.Insert(insertIndex, symbol);
            }

            // Add all words from this line to results (including any missed symbols)
            result.GroupedWords.AddRange(lineWords);

            // Step 6: Update marching Y to continue searching down from this line
            marchingY = lineWords.Max(w => w.RawY2);
        }

        result.Success = result.GroupedWords.Count > 1;
        result.CombinedText = string.Join("\n", result.GroupedWords.Select(w => w.Text));

        // Add metadata
        result.AddMetadata("SearchTerm", State.PatternSearchTerm);
        result.AddMetadata("PatternType", State.SelectedPatternType);
        result.AddMetadata("YTolerance", State.PatternYTolerance);
        result.AddMetadata("XTolerance", State.PatternXTolerance);
        result.AddMetadata("AnchorPosition", $"{anchorWord.RawX1},{anchorWord.RawY1}");
        result.AddMetadata("MarchingCoordinate", $"{marchingX},{marchingY}");

        return result;
    }

    // Styling methods
    private string GetHeatWordStyle(WordBoundingBox word)
    {
        var left = (word.NormX1 * 100);
        var top = (word.NormY1 * 100);
        var width = ((word.NormX2 - word.NormX1) * 100);
        var height = ((word.NormY2 - word.NormY1) * 100);

        return $"position: absolute; left: {left:F2}%; top: {top:F2}%; " +
               $"width: {width:F2}%; height: {height:F2}%; " +
               $"background-color: rgba(0, 123, 255, 0.2); border: 1px solid rgba(0, 123, 255, 0.4); " +
               $"pointer-events: auto; cursor: pointer; z-index: 10; transition: all 0.2s ease;";
    }

    private string GetPatternAnchorStyle(WordBoundingBox word)
    {
        var left = (word.NormX1 * 100);
        var top = (word.NormY1 * 100);
        var width = ((word.NormX2 - word.NormX1) * 100);
        var height = ((word.NormY2 - word.NormY1) * 100);

        return $"position: absolute; left: {left:F2}%; top: {top:F2}%; " +
               $"width: {width:F2}%; height: {height:F2}%; " +
               $"background-color: rgba(255, 0, 0, 0.6); border: 2px solid rgba(255, 0, 0, 0.9); " +
               $"pointer-events: auto; cursor: pointer; z-index: 30; transition: all 0.2s ease; " +
               $"border-radius: 2px;";
    }

    private string GetPatternGroupStyle(WordBoundingBox word)
    {
        var left = (word.NormX1 * 100);
        var top = (word.NormY1 * 100);
        var width = ((word.NormX2 - word.NormX1) * 100);
        var height = ((word.NormY2 - word.NormY1) * 100);

        return $"position: absolute; left: {left:F2}%; top: {top:F2}%; " +
               $"width: {width:F2}%; height: {height:F2}%; " +
               $"background-color: rgba(0, 255, 0, 0.6); border: 2px solid rgba(0, 255, 0, 0.9); " +
               $"pointer-events: auto; cursor: pointer; z-index: 20; transition: all 0.2s ease; " +
               $"border-radius: 2px;";
    }

    private async Task CopyWordToClipboard(string word)
    {
        if (string.IsNullOrEmpty(word)) return;

        try
        {
            await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", word);
        }
        catch (Exception)
        {
            // Fallback for older browsers - could show a message
        }
    }

    // NEW: Test callback for the component
    private void TestPatternCallback(SearchPattern pattern)
    {
        Console.WriteLine($"Received pattern: {pattern.SearchName}");
    }

    private SearchPattern? GetCurrentSearchPattern()
    {
        if (string.IsNullOrEmpty(State.PatternSearchTerm))
            return null;

        return new SearchPattern
            {
                SearchName = State.PatternSearchTerm,
                KeyWord = State.PatternSearchTerm,
                PatternType = State.SelectedPatternType ?? "VerticalColumn",
                ToleranceX = State.PatternXTolerance,
                ToleranceY = State.PatternYTolerance,
                StopWords = State.PatternStopWords ?? "",
                RegexPatterns = currentRegexPatterns.ToList() // Use the full list instead of single pattern
            };
    }

    // NEW: Methods for managing regex patterns
    private async Task AddRegexPattern()
    {
        if (!string.IsNullOrWhiteSpace(newRegexPattern) && !currentRegexPatterns.Contains(newRegexPattern))
        {
            var trimmedPattern = newRegexPattern.Trim();
            currentRegexPatterns.Add(trimmedPattern);

            // Debug: Log what we're adding
            Console.WriteLine($"Added regex pattern: '{trimmedPattern}'");
            Console.WriteLine($"Total patterns now: {currentRegexPatterns.Count}");
            foreach (var p in currentRegexPatterns)
            {
                Console.WriteLine($"  - '{p}'");
            }

            newRegexPattern = "";

            // Update legacy single pattern for compatibility
            currentRegexPattern = currentRegexPatterns.FirstOrDefault() ?? "";
            StateHasChanged();
        }
    }

    private void RemoveRegexPattern(int index)
    {
        if (index >= 0 && index < currentRegexPatterns.Count)
        {
            var removedPattern = currentRegexPatterns[index];
            currentRegexPatterns.RemoveAt(index);

            // Debug: Log what we're removing
            Console.WriteLine($"Removed regex pattern: '{removedPattern}'");
            Console.WriteLine($"Remaining patterns: {currentRegexPatterns.Count}");

            // Update legacy single pattern for compatibility
            currentRegexPattern = currentRegexPatterns.FirstOrDefault() ?? "";
            StateHasChanged();
        }
    }

    private void OnPatternSaved()
    {
        // Just refresh the UI
        StateHasChanged();
    }
}