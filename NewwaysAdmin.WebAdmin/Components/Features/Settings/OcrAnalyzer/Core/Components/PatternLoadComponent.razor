@* NewwaysAdmin.WebAdmin/Components/Features/Settings/OcrAnalyzer/Core/Components/PatternLoadComponent.razor *@
@* REFACTORED: Now uses PatternLoaderService for all business logic *@
@using NewwaysAdmin.SharedModels.Models.Ocr
@using NewwaysAdmin.SharedModels.Models.Ocr.Core
@inject PatternLoaderService PatternLoader
@inject IJSRuntime JSRuntime

<div class="pattern-load-panel">
    <h6><i class="bi bi-folder-open"></i> Load Pattern - 3-Level Structure</h6>

    <!-- Step 1: Document Type Selection -->
    <div class="mb-3">
        <label class="form-label"><strong>Step 1: Document Type</strong></label>
        <div class="input-group">
            <select @onchange="OnDocumentTypeChanged" class="form-select" value="@selectedDocumentType">
                <option value="">-- Select Document Type --</option>
                @foreach (var docType in availableDocumentTypes)
                {
                    <option value="@docType">@docType</option>
                }
            </select>
            <button @onclick="LoadDocumentTypes" class="btn btn-outline-secondary" type="button" title="Refresh">
                <i class="bi bi-arrow-clockwise"></i>
            </button>
        </div>
    </div>

    <!-- Step 2: Sub Collection Selection (only show when document type is selected) -->
    @if (!string.IsNullOrEmpty(selectedDocumentType))
    {
        <div class="mb-3">
            <label class="form-label"><strong>Step 2: Sub Collection</strong></label>
            <select @onchange="OnSubCollectionChanged" class="form-select" value="@selectedSubCollection">
                <option value="">-- Select Sub Collection --</option>
                @foreach (var subCollection in availableSubCollections)
                {
                    <option value="@subCollection">@subCollection</option>
                }
            </select>
        </div>
    }

    <!-- Step 3: Pattern Selection (only show when both levels are selected) -->
    @if (!string.IsNullOrEmpty(selectedDocumentType) && !string.IsNullOrEmpty(selectedSubCollection))
    {
        <div class="mb-3">
            <label class="form-label"><strong>Step 3: Pattern</strong></label>
            <select @bind="selectedPattern" class="form-select">
                <option value="">-- Select Pattern --</option>
                @foreach (var pattern in availablePatterns)
                {
                    <option value="@pattern">@pattern</option>
                }
            </select>
        </div>
    }

    <!-- Load Button -->
    <div class="d-grid">
        <button @onclick="LoadSelectedPattern"
                class="btn btn-success"
                disabled="@(string.IsNullOrEmpty(selectedDocumentType) || string.IsNullOrEmpty(selectedSubCollection) || string.IsNullOrEmpty(selectedPattern) || isLoading)">
            @if (isLoading)
            {
                <span class="spinner-border spinner-border-sm me-2"></span>
            }
            <i class="bi bi-download"></i> Load "@selectedPattern" from @selectedDocumentType → @selectedSubCollection
        </button>
    </div>

    <!-- Status Messages -->
    @if (!string.IsNullOrEmpty(statusMessage))
    {
        <div class="alert @(isError ? "alert-danger" : "alert-success") mt-3 mb-0">
            <i class="bi @(isError ? "bi-exclamation-triangle" : "bi-check-circle")"></i>
            @statusMessage
        </div>
    }
</div>

@code {
    [Parameter] public EventCallback<SearchPattern> OnPatternLoaded { get; set; }

    // UI State - much simpler now!
    private List<string> availableDocumentTypes = new();
    private List<string> availableSubCollections = new();
    private List<string> availablePatterns = new();

    private string selectedDocumentType = "";
    private string selectedSubCollection = "";
    private string selectedPattern = "";

    private bool isLoading = false;
    private string statusMessage = "";
    private bool isError = false;

    protected override async Task OnInitializedAsync()
    {
        await LoadDocumentTypes();
    }

    private async Task LoadDocumentTypes()
    {
        try
        {
            isLoading = true;
            StateHasChanged();

            // ALL business logic is now in the service!
            availableDocumentTypes = await PatternLoader.GetDocumentTypesAsync();

            // Clear all selections if document type list changed
            selectedDocumentType = "";
            selectedSubCollection = "";
            selectedPattern = "";
            availableSubCollections.Clear();
            availablePatterns.Clear();

            ClearStatus();
        }
        catch (Exception ex)
        {
            ShowError($"Error loading document types: {ex.Message}");
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }

    private async Task OnDocumentTypeChanged(ChangeEventArgs e)
    {
        selectedDocumentType = e.Value?.ToString() ?? "";
        selectedSubCollection = "";
        selectedPattern = "";
        availableSubCollections.Clear();
        availablePatterns.Clear();

        if (!string.IsNullOrEmpty(selectedDocumentType))
        {
            try
            {
                // Service handles all the logic
                availableSubCollections = await PatternLoader.GetSubCollectionsAsync(selectedDocumentType);
                ClearStatus();
            }
            catch (Exception ex)
            {
                ShowError($"Error loading sub collections: {ex.Message}");
            }
        }

        StateHasChanged();
    }

    private async Task OnSubCollectionChanged(ChangeEventArgs e)
    {
        selectedSubCollection = e.Value?.ToString() ?? "";
        selectedPattern = "";
        availablePatterns.Clear();

        if (!string.IsNullOrEmpty(selectedDocumentType) && !string.IsNullOrEmpty(selectedSubCollection))
        {
            try
            {
                // Service handles all the logic
                availablePatterns = await PatternLoader.GetPatternNamesAsync(selectedDocumentType, selectedSubCollection);
                ClearStatus();
            }
            catch (Exception ex)
            {
                ShowError($"Error loading patterns: {ex.Message}");
            }
        }

        StateHasChanged();
    }

    private async Task LoadSelectedPattern()
    {
        if (string.IsNullOrEmpty(selectedDocumentType) ||
            string.IsNullOrEmpty(selectedSubCollection) ||
            string.IsNullOrEmpty(selectedPattern))
            return;

        try
        {
            isLoading = true;
            ClearStatus();
            StateHasChanged();

            // Service handles all the business logic - clean and simple!
            var pattern = await PatternLoader.LoadPatternAsync(selectedDocumentType, selectedSubCollection, selectedPattern);

            if (pattern != null)
            {
                // Notify parent component that pattern was loaded
                await OnPatternLoaded.InvokeAsync(pattern);

                ShowSuccess($"Pattern '{selectedPattern}' loaded successfully from {selectedDocumentType} → {selectedSubCollection}!");
            }
            else
            {
                ShowError($"Pattern '{selectedPattern}' not found in {selectedDocumentType} → {selectedSubCollection}");
            }
        }
        catch (Exception ex)
        {
            ShowError($"Error loading pattern: {ex.Message}");
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }

    // Simple UI state management methods
    private void ShowSuccess(string message)
    {
        statusMessage = message;
        isError = false;
    }

    private void ShowError(string message)
    {
        statusMessage = message;
        isError = true;
    }

    private void ClearStatus()
    {
        statusMessage = "";
        isError = false;
    }
}